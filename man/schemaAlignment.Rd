% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/schemaAlignment.R
\name{schemaAlignment}
\alias{schemaAlignment}
\title{schemaAlignment}
\usage{
schemaAlignment(x, y)
}
\arguments{
\item{x}{a data frame.}

\item{y}{a similar data frame that might include additions like new rows, new columns or changed column names and/or positions.}
}
\value{
A new data frame that will include all columns that match 100% by name or by content. It follows the column arrangement of dataset #1 as closely as possible. But it only keeps the content of the second dataset.
}
\description{
Identify similarity between 2 datasets and generate a new one that follows as much as possible the schema available in the first dataset while keeping the info available in the second dataset.
}
\details{
This function will take two  data frames as input and it will try to make the second one \code{y}
fit into the first one's \code{x} schema. Ideally \code{y} should be an updated messy version of \code{x}.
The function will try to find matches by name first, then by content by running an iterative match search operation.
These second level operations try to find a match between columns in \code{x} and \code{y}.
Only those columns that did not match by name are considered for this second step. If there is a match by content,
the column in data frame \code{y} gets renamed according to data frame \code{x}. Then, all those non matching fields
are silently dropped and columns in data frame \code{y} are ordered as closely as possible to the original column
arrangement in \code{x}. Best if used for small datasets around 10K rows max. Currently there is no option to avoid
dropping non-matching columns.This function is verbose as it tries to provide as much visibility as possible to final
user as to what is being done under the hood. It will output some debugging flags as well as the name of the columns
being dropped from each dataset. Still work in progress.
}
\examples{
\dontrun{
z <- schemaAlignment(x,y)
}
}
